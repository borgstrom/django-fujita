import uuid

from tornado import ioloop, process

class DjangoRunner(object):
    """
    The DjangoRunner interface. It launches the django runserver command, or
    any command really, and provides a buffer for the stdout & stderr that is
    generated by the process.

    Waiters will receive lists with three items, the first is a UUID to id this
    specific message, the second is the file handle the message came in on (0
    for stdout, 1 for stderr) and the last is the line received.
    """
    def __init__(self, command, **process_kwargs):
        print "Initializing Django Runner"

        # setup our variables used to track callbacks and manage the cache
        self.waiters = set()
        self.cache = []
        self.cache_size = 500

        # prepare the command & kwargs for the subprocess
        if isinstance(command, list):
            command = " ".join(command)

        # Set shell, stdout & stderr in our kwargs to ensure that we use the
        # proper values. We need to use the shell to ensure that we maintain
        # streams to stdout & stderr so that as the django server restarts
        # our subprocess stays connected
        if not process_kwargs:
            process_kwargs = dict()

        process_kwargs.update(dict(
            shell=True,
            stdout=process.Subprocess.STREAM,
            stderr=process.Subprocess.STREAM
        ))

        # start the process and begin reading our streams
        print "Starting subprocess: %s" % command
        self.process = process.Subprocess(command, **process_kwargs)
        self.read_until(self.process.stdout, self.handle_stdout)
        self.read_until(self.process.stderr, self.handle_stderr)

        # setup an exit callback
        self.process.set_exit_callback(self.process_exit)

    def add_waiter(self, callback):
        """
        Start waiting for output, any lines output will be sent to the callback
        specified.

        If cursor is supplied any items in the cache newer than the cursor will
        be sent to the callback.
        """
        print "Adding new waiter %s. Sending %d cache items" % (callback, len(self.cache))
        for id, fd, line in self.cache:
            callback(id, fd, line)

        self.waiters.add(callback)

    def remove_waiter(self, callback):
        print "Removing waiter %s" % callback
        self.waiters.remove(callback)

    def process_exit(self, retcode):
        print "Django exited with return code %d" % retcode

    def send_line_to_waiters(self, fd, line):
        # generate an id and add it to the cache
        id = str(uuid.uuid4())
        self.cache.append((id, fd, line))

        # send it to the waiters
        for callback in self.waiters:
            callback(id, fd, line)

        # trim cache, if necessary
        if len(self.cache) > self.cache_size:
            self.cache = self.cache[-self.cache_size:]

    def read_until(self, stream, callback):
        stream.read_until("\n", callback)

    def handle_stdout(self, line):
        self.send_line_to_waiters(0, line)
        self.read_until(self.process.stdout, self.handle_stdout)

    def handle_stderr(self, line):
        self.send_line_to_waiters(1, line)
        self.read_until(self.process.stderr, self.handle_stderr)

if __name__ == '__main__':
    main_ioloop = ioloop.IOLoop.instance()
    runner = DjangoRunner()
    main_ioloop.start()
